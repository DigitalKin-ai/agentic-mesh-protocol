// Copyright 2025 DigitalKin Inc.
//
// Licensed under the GNU General Public License, Version 3.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.gnu.org/licenses/gpl-3.0.html
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package agentic_mesh_protocol.filesystem.v1;

import "buf/validate/validate.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";

// FileType represents the classification of file types in the system.
enum FileType {
  // FILE_TYPE_UNSPECIFIED is the default unspecified value.
  FILE_TYPE_UNSPECIFIED = 0;
  // FILE_TYPE_DOCUMENT represents document files (PDF, DOC, TXT, etc.).
  FILE_TYPE_DOCUMENT = 1;
  // FILE_TYPE_IMAGE represents image files (PNG, JPG, GIF, etc.).
  FILE_TYPE_IMAGE = 2;
  // FILE_TYPE_VIDEO represents video files (MP4, AVI, MOV, etc.).
  FILE_TYPE_VIDEO = 3;
  // FILE_TYPE_AUDIO represents audio files (MP3, WAV, etc.).
  FILE_TYPE_AUDIO = 4;
  // FILE_TYPE_ARCHIVE represents archive files (ZIP, TAR, etc.).
  FILE_TYPE_ARCHIVE = 5;
  // FILE_TYPE_CODE represents source code files.
  FILE_TYPE_CODE = 6;
  // FILE_TYPE_OTHER represents other file types.
  FILE_TYPE_OTHER = 7;
}

// FileStatus represents the lifecycle status of a file in the system.
enum FileStatus {
  // FILE_STATUS_UNSPECIFIED is the default unspecified value.
  FILE_STATUS_UNSPECIFIED = 0;
  // FILE_STATUS_UPLOADING indicates the file is currently being uploaded.
  FILE_STATUS_UPLOADING = 1;
  // FILE_STATUS_ACTIVE indicates the file is active and available for use.
  FILE_STATUS_ACTIVE = 2;
  // FILE_STATUS_PROCESSING indicates the file is being processed.
  FILE_STATUS_PROCESSING = 3;
  // FILE_STATUS_ARCHIVED indicates the file has been archived.
  FILE_STATUS_ARCHIVED = 4;
  // FILE_STATUS_DELETED indicates the file is marked for deletion.
  FILE_STATUS_DELETED = 5;
}

// File represents a stored file with comprehensive metadata.
message File {
  // file_id: Unique identifier for the file
  string file_id = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.pattern = "^files:.*$"
  ];

  // context: Context ID linked to the file
  string context = 2 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.pattern = "^(missions:|setups:).*$"
  ];

  // name: Name of the file (unique within context)
  string name = 3 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.min_len = 1
  ];

  // file_type: Type classification of the file
  FileType file_type = 4 [
    (buf.validate.field).required = true,
    (buf.validate.field).enum.not_in = 0
  ];

  // content_type: MIME type of the file
  string content_type = 5 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.min_len = 1
  ];

  // size_bytes: Size of the file in bytes
  int64 size_bytes = 6 [
    (buf.validate.field).required = true,
    (buf.validate.field).int64.gte = 0
  ];

  // checksum: SHA-256 checksum of the file content (SHA-256 format)
  string checksum = 7 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.min_len = 1
  ];

  // metadata: Flexible metadata for additional file properties
  google.protobuf.Struct metadata = 8;

  // storage_uri: Internal URI for accessing the file content
  string storage_uri = 9 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.min_len = 1
  ];

  // file_url: External URL for accessing the file content
  string file_url = 10 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.min_len = 1
  ];

  // status: Current status of the file
  FileStatus status = 11 [
    (buf.validate.field).required = true,
    (buf.validate.field).enum.not_in = 0
  ];

  // content: The content of the file
  bytes content = 12;
}

// FileFilter contains criteria for querying and filtering files.
message FileFilter {
  // names: Filter by file names (exact matches)
  repeated string names = 1;

  // file_ids: Filter by file IDs
  repeated string file_ids = 2 [(buf.validate.field).repeated.items.string.pattern = "^files:.*$"];

  // file_types: Filter by file types
  repeated FileType file_types = 3 [(buf.validate.field).repeated.items.enum.not_in = 0];

  // context: Filter by context (required for scoping)
  string context = 4 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.pattern = "^(missions:|setups:).*$"
  ];

  // created_after: Filter files created after this timestamp
  google.protobuf.Timestamp created_after = 5;

  // created_before: Filter files created before this timestamp
  google.protobuf.Timestamp created_before = 6;

  // updated_after: Filter files updated after this timestamp
  google.protobuf.Timestamp updated_after = 7;

  // updated_before: Filter files updated before this timestamp
  google.protobuf.Timestamp updated_before = 8;

  // status: Filter by file status
  FileStatus status = 9;

  // content_type_prefix: Filter by content type prefix (e.g., "image/")
  string content_type_prefix = 10;

  // min_size_bytes: Filter files with minimum size
  int64 min_size_bytes = 11 [(buf.validate.field).int64.gte = 0];

  // max_size_bytes: Filter files with maximum size
  int64 max_size_bytes = 12 [(buf.validate.field).int64.gte = 0];

  // prefix: Filter by path prefix (e.g., "/folder1/"). Prevents path traversal (no ".." allowed).
  string prefix = 13 [(buf.validate.field).string.pattern = "^[^.]*([.][^.]+)*[.]?$"];

  // content_type: Filter by content type
  string content_type = 14;
}

// FileResult wraps the result of a file operation which may succeed or fail.
message FileResult {
  // result contains either a successfully processed file or error information.
  oneof result {
    // file: Successfully processed file
    File file = 1;
    // error: Error information if operation failed
    string error = 2;
  }
}

// UploadFileData contains the data required for uploading a single file.
message UploadFileData {
  // context: Context ID for the file
  string context = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.pattern = "(^(missions:|setups:).*$|^default$)"
  ];

  // name: Name of the file
  string name = 2 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.min_len = 1,
    (buf.validate.field).string.pattern = "^[^.]*([.][^.]+)*[.]?$"
  ];

  // file_type: Type classification of the file
  FileType file_type = 3 [
    (buf.validate.field).required = true,
    (buf.validate.field).enum.not_in = 0
  ];

  // content_type: MIME type of the file
  string content_type = 4 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.min_len = 1
  ];

  // content: File content
  bytes content = 5 [
    (buf.validate.field).required = true,
    (buf.validate.field).bytes.min_len = 1
  ];

  // metadata: Additional metadata for the file
  google.protobuf.Struct metadata = 6;

  // status: Status of the file
  FileStatus status = 7 [
    (buf.validate.field).required = true,
    (buf.validate.field).enum.not_in = 0
  ];

  // replace_if_exists: Whether to replace existing file with same name
  bool replace_if_exists = 8;
}

// UploadFilesRequest is the request message for uploading multiple files.
message UploadFilesRequest {
  // files: List of files to upload
  repeated UploadFileData files = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).repeated.min_items = 1
  ];
}

// UploadFilesResponse is the response message for file upload operations.
message UploadFilesResponse {
  // results: Results for each uploaded file
  repeated FileResult results = 1;

  // total_uploaded: Number of successfully uploaded files
  int32 total_uploaded = 2 [(buf.validate.field).int32.gte = 0];

  // total_failed: Number of failed uploads
  int32 total_failed = 3 [(buf.validate.field).int32.gte = 0];
}

// GetFileRequest is the request message for retrieving a specific file.
message GetFileRequest {
  // context: Context ID for the file
  string context = 1 [
    (buf.validate.field).string.pattern = "^(missions:|setups:).*$"
  ];

  // file_id: File ID
  string file_id = 2 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.pattern = "^files:.*$"
  ];

  // include_content: Whether to include file content in response
  bool include_content = 3;
}

// GetFileResponse is the response message containing file information.
message GetFileResponse {
  // file: The requested file
  File file = 1 [(buf.validate.field).required = true];

  // content: File content (only if requested)
  bytes content = 2;
}

// UpdateFileRequest is the request message for updating a file.
message UpdateFileRequest {
  // context: Context ID for the file
  string context = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.pattern = "^(missions:|setups:).*$"
  ];

  // file_id: Current id of the file
  string file_id = 2 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.pattern = "^files:.*$"
  ];

  // new_name: New name for the file (optional)
  string new_name = 3 [(buf.validate.field).string.min_len = 1];

  // file_type: New file type (optional, cannot be UNSPECIFIED)
  FileType file_type = 4 [(buf.validate.field).enum.not_in = 0];

  // content_type: New content type (optional)
  string content_type = 5 [(buf.validate.field).string.min_len = 1];

  // content: New file content (optional)
  bytes content = 6;

  // status: New status of the file
  FileStatus status = 7 [
    (buf.validate.field).required = true,
    (buf.validate.field).enum.not_in = 0
  ];

  // metadata: New metadata (optional, will merge with existing)
  google.protobuf.Struct metadata = 8;
}

// UpdateFileResponse is the response message for file update operations.
message UpdateFileResponse {
  // result: Result of the file update operation
  FileResult result = 1;
}

// GetFilesRequest is the request message for retrieving multiple files by various criteria.
message GetFilesRequest {
  // context: Context ID for the files
  string context = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.pattern = "^(missions:|setups:).*$"
  ];

  // filters: How to identify the files
  FileFilter filters = 2 [(buf.validate.field).required = true];

  // list_size: Number of files to return per page
  int32 list_size = 3 [
    (buf.validate.field).int32.gte = 1,
    (buf.validate.field).int32.lte = 1000
  ];

  // offset: Offset of the first file in the list
  int32 offset = 4 [(buf.validate.field).int32.gte = 0];

  // order: Field to order results by
  string order = 5;

  // include_content: Whether to include file content in response
  bool include_content = 6;
}

// GetFilesResponse is the response message containing multiple files.
message GetFilesResponse {
  // files: List of files matching the criteria
  repeated File files = 1;

  // total_count: Total number of files matching the criteria
  int32 total_count = 2 [(buf.validate.field).int32.gte = 0];
}

// DeleteFilesRequest is the request message for deleting multiple files.
message DeleteFilesRequest {
  // context: Context ID for the files
  string context = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.pattern = "^(missions:|setups:).*$"
  ];

  // filters: How to identify the files
  FileFilter filters = 2 [(buf.validate.field).required = true];

  // force: Whether to force delete even if file is in use
  bool force = 3;

  // permanent: Whether to permanently delete (vs mark as deleted)
  bool permanent = 4;
}

// DeleteFilesResponse is the response message for file deletion operations.
message DeleteFilesResponse {
  // results: Results for each file deletion attempt
  map<string, bool> results = 1;

  // total_deleted: Number of successfully deleted files
  int32 total_deleted = 2 [(buf.validate.field).int32.gte = 0];

  // total_failed: Number of failed deletions
  int32 total_failed = 3 [(buf.validate.field).int32.gte = 0];
}
