// Copyright 2025 DigitalKin Inc.
//
// Licensed under the GNU General Public License, Version 3.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.gnu.org/licenses/gpl-3.0.html
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package agentic_mesh_protocol.filesystem.v1;

import "buf/validate/validate.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";

// FileType: Enum for file type classification
enum FileType {
  // FILE_TYPE_UNSPECIFIED: Default value, should not be used
  FILE_TYPE_UNSPECIFIED = 0;
  // FILE_TYPE_DOCUMENT: Document files (PDF, DOC, TXT, etc.)
  FILE_TYPE_DOCUMENT = 1;
  // FILE_TYPE_IMAGE: Image files (PNG, JPG, GIF, etc.)
  FILE_TYPE_IMAGE = 2;
  // FILE_TYPE_VIDEO: Video files (MP4, AVI, MOV, etc.)
  FILE_TYPE_VIDEO = 3;
  // FILE_TYPE_AUDIO: Audio files (MP3, WAV, etc.)
  FILE_TYPE_AUDIO = 4;
  // FILE_TYPE_ARCHIVE: Archive files (ZIP, TAR, etc.)
  FILE_TYPE_ARCHIVE = 5;
  // FILE_TYPE_CODE: Source code files
  FILE_TYPE_CODE = 6;
  // FILE_TYPE_OTHER: Other file types
  FILE_TYPE_OTHER = 7;
}

// FileStatus: Enum for file status in the system
enum FileStatus {
  // FILE_STATUS_UNSPECIFIED: Default value, should not be used
  FILE_STATUS_UNSPECIFIED = 0;
  // FILE_STATUS_UPLOADING: File is being uploaded
  FILE_STATUS_UPLOADING = 1;
  // FILE_STATUS_ACTIVE: File is active and available
  FILE_STATUS_ACTIVE = 2;
  // FILE_STATUS_PROCESSING: File is being processed
  FILE_STATUS_PROCESSING = 3;
  // FILE_STATUS_ARCHIVED: File is archived
  FILE_STATUS_ARCHIVED = 4;
  // FILE_STATUS_DELETED: File is marked for deletion
  FILE_STATUS_DELETED = 5;
}

// File: Message to represent stored files with comprehensive metadata
message File {
  // file_id: Unique identifier for the file (UUID)
  string file_id = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.uuid = true
  ];

  // context: Context ID linked to the file
  string context = 2 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.pattern = "^(missions:|setups:).*$"
  ];

  // name: Name of the file (unique within context)
  string name = 3 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.min_len = 1
  ];

  // file_type: Type classification of the file
  FileType file_type = 4 [
    (buf.validate.field).required = true,
    (buf.validate.field).enum.not_in = 0
  ];

  // content_type: MIME type of the file
  string content_type = 5 [(buf.validate.field).required = true];

  // size_bytes: Size of the file in bytes
  int64 size_bytes = 6 [
    (buf.validate.field).required = true,
    (buf.validate.field).int64.gte = 0
  ];

  // checksum: SHA-256 checksum of the file content
  string checksum = 7 [(buf.validate.field).required = true];

  // metadata: Flexible metadata for additional file properties
  google.protobuf.Struct metadata = 8;

  // storage_uri: Internal URI for accessing the file content
  string storage_uri = 9 [(buf.validate.field).required = true];

  // file_url: External URL for accessing the file content
  string file_url = 10 [(buf.validate.field).required = true];

  // status: Current status of the file
  FileStatus status = 11 [
    (buf.validate.field).required = true,
    (buf.validate.field).enum.not_in = 0
  ];

  // content: The content of the file
  bytes content = 12;
}

// FileFilter: Filter criteria for querying files
message FileFilter {
  // names: Filter by file names (exact matches)
  repeated string names = 1;

  // file_ids: Filter by file IDs
  repeated string file_ids = 2 [(buf.validate.field).repeated.items.string.uuid = true];

  // file_types: Filter by file types
  repeated FileType file_types = 3 [(buf.validate.field).repeated.items.enum.not_in = 0];

  // context: Filter by context (required for scoping)
  string context = 4 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.pattern = "^(missions:|setups:).*$"
  ];

  // created_after: Filter files created after this timestamp
  google.protobuf.Timestamp created_after = 5;

  // created_before: Filter files created before this timestamp
  google.protobuf.Timestamp created_before = 6;

  // updated_after: Filter files updated after this timestamp
  google.protobuf.Timestamp updated_after = 7;

  // updated_before: Filter files updated before this timestamp
  google.protobuf.Timestamp updated_before = 8;

  // status: Filter by file status
  FileStatus status = 9;

  // content_type_prefix: Filter by content type prefix (e.g., "image/")
  string content_type_prefix = 10;

  // min_size_bytes: Filter files with minimum size
  int64 min_size_bytes = 11 [(buf.validate.field).int64.gte = 0];

  // max_size_bytes: Filter files with maximum size
  int64 max_size_bytes = 12 [(buf.validate.field).int64.gte = 0];

  // prefix: Filter by path prefix (e.g., "folder1/")
  string prefix = 13 [(buf.validate.field).string.pattern = "^[^/]*/?[^/]*$"];

  // content_type: Filter by content type
  string content_type = 14;
}

// FileResult: Wrapper for file operations that may succeed or fail
message FileResult {
  // result: The result of the file operation (either success or error)
  oneof result {
    // file: Successfully processed file
    File file = 1;
    // error: Error information if operation failed
    string error = 2;
  }
}

// UploadFileData: Data for uploading a single file
message UploadFileData {
  // context: Context ID for the file
  string context = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.pattern = "^(missions:|setups:).*$"
  ];

  // name: Name of the file
  string name = 2 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.min_len = 1
  ];

  // file_type: Type classification of the file
  FileType file_type = 3 [
    (buf.validate.field).required = true,
    (buf.validate.field).enum.not_in = 0
  ];

  // content_type: MIME type of the file
  string content_type = 4 [(buf.validate.field).required = true];

  // content: File content
  bytes content = 5 [(buf.validate.field).required = true];

  // metadata: Additional metadata for the file
  google.protobuf.Struct metadata = 6;

  // status: Status of the file
  FileStatus status = 7 [
    (buf.validate.field).required = true,
    (buf.validate.field).enum.not_in = 0
  ];

  // replace_if_exists: Whether to replace existing file with same name
  bool replace_if_exists = 8;
}

// UploadFilesRequest: Request to upload multiple files
message UploadFilesRequest {
  // files: List of files to upload
  repeated UploadFileData files = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).repeated.min_items = 1
  ];
}

// UploadFilesResponse: Response for file upload operations
message UploadFilesResponse {
  // results: Results for each uploaded file
  repeated FileResult results = 1;

  // total_uploaded: Number of successfully uploaded files
  int32 total_uploaded = 2;

  // total_failed: Number of failed uploads
  int32 total_failed = 3;
}

// GetFileRequest: Request to get a specific file
message GetFileRequest {
  // context: Context ID for the file
  string context = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.pattern = "^(missions:|setups:).*$"
  ];

  // file_id: File ID
  string file_id = 2 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.uuid = true
  ];

  // include_content: Whether to include file content in response
  bool include_content = 3;
}

// GetFileResponse: Response containing file information
message GetFileResponse {
  // file: The requested file
  File file = 1 [(buf.validate.field).required = true];

  // content: File content (only if requested)
  bytes content = 2;
}

// UpdateFileRequest: Request to update a file
message UpdateFileRequest {
  // context: Context ID for the file
  string context = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.pattern = "^(missions:|setups:).*$"
  ];

  // file_id: Current id of the file
  string file_id = 2 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.uuid = true
  ];

  // new_name: New name for the file (optional)
  string new_name = 3;

  // file_type: New file type (optional)
  FileType file_type = 4;

  // content_type: New content type (optional)
  string content_type = 5;

  // content: New file content (optional)
  bytes content = 6;

  // status: New status of the file
  FileStatus status = 7 [
    (buf.validate.field).required = true,
    (buf.validate.field).enum.not_in = 0
  ];

  // metadata: New metadata (optional, will merge with existing)
  google.protobuf.Struct metadata = 8;
}

// UpdateFileResponse: Response for file update
message UpdateFileResponse {
  // result: Result of the file update operation
  FileResult result = 1;
}

// GetFilesRequest: Request to get multiple files by various criteria
message GetFilesRequest {
  // context: Context ID for the files
  string context = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.pattern = "^(missions:|setups:).*$"
  ];

  // filters: How to identify the files
  FileFilter filters = 2 [(buf.validate.field).required = true];

  // list_size: Number of files to return per page
  int32 list_size = 3 [
    (buf.validate.field).int32.gte = 1,
    (buf.validate.field).int32.lte = 1000
  ];

  // offset: Offset of the first file in the list
  int32 offset = 4 [(buf.validate.field).int32.gte = 0];

  // order: Field to order results by
  string order = 5;

  // include_content: Whether to include file content in response
  bool include_content = 6;
}

// GetFilesResponse: Response containing multiple files
message GetFilesResponse {
  // files: List of files matching the criteria
  repeated File files = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).repeated.min_items = 1
  ];

  // total_count: Total number of files matching the criteria
  int32 total_count = 2;
}

// DeleteFilesRequest: Request to delete multiple files
message DeleteFilesRequest {
  // context: Context ID for the files
  string context = 1 [
    (buf.validate.field).required = true,
    (buf.validate.field).string.pattern = "^(missions:|setups:).*$"
  ];

  // filters: How to identify the files
  FileFilter filters = 2 [(buf.validate.field).required = true];

  // force: Whether to force delete even if file is in use
  bool force = 3;

  // permanent: Whether to permanently delete (vs mark as deleted)
  bool permanent = 4;
}

// DeleteFilesResponse: Response for file deletion
message DeleteFilesResponse {
  // results: Results for each file deletion attempt
  map<string, bool> results = 1;

  // total_deleted: Number of successfully deleted files
  int32 total_deleted = 2;

  // total_failed: Number of failed deletions
  int32 total_failed = 3;
}
