// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               unknown
// source: agentic_mesh_protocol/cost/v1/cost.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "agentic_mesh_protocol.cost.v1";

/** CostType represents the classification of cost types in the system. */
export enum CostType {
  /** UNSPECIFIED - UNSPECIFIED is the default unspecified value. */
  UNSPECIFIED = 0,
  /** TOKEN_INPUT - TOKEN_INPUT represents token input costs. */
  TOKEN_INPUT = 1,
  /** TOKEN_OUTPUT - TOKEN_OUTPUT represents token output costs. */
  TOKEN_OUTPUT = 2,
  /** API_CALL - API_CALL represents API call costs. */
  API_CALL = 3,
  /** STORAGE - STORAGE represents storage costs. */
  STORAGE = 4,
  /** TIME - TIME represents time-based costs. */
  TIME = 5,
  /** OTHER - OTHER represents other types of costs. */
  OTHER = 6,
  UNRECOGNIZED = -1,
}

export function costTypeFromJSON(object: any): CostType {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return CostType.UNSPECIFIED;
    case 1:
    case "TOKEN_INPUT":
      return CostType.TOKEN_INPUT;
    case 2:
    case "TOKEN_OUTPUT":
      return CostType.TOKEN_OUTPUT;
    case 3:
    case "API_CALL":
      return CostType.API_CALL;
    case 4:
    case "STORAGE":
      return CostType.STORAGE;
    case 5:
    case "TIME":
      return CostType.TIME;
    case 6:
    case "OTHER":
      return CostType.OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CostType.UNRECOGNIZED;
  }
}

export function costTypeToJSON(object: CostType): string {
  switch (object) {
    case CostType.UNSPECIFIED:
      return "UNSPECIFIED";
    case CostType.TOKEN_INPUT:
      return "TOKEN_INPUT";
    case CostType.TOKEN_OUTPUT:
      return "TOKEN_OUTPUT";
    case CostType.API_CALL:
      return "API_CALL";
    case CostType.STORAGE:
      return "STORAGE";
    case CostType.TIME:
      return "TIME";
    case CostType.OTHER:
      return "OTHER";
    case CostType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Cost represents a cost entry with comprehensive tracking information. */
export interface Cost {
  /** cost is the total cost value. */
  cost: number;
  /** mission_id is the mission ID linked to this cost. */
  missionId: string;
  /** name is the descriptive name of the cost. */
  name: string;
  /** cost_type is the classification of the cost. */
  costType: CostType;
  /** unit is the unit of measurement for the cost (e.g., "tokens", "calls", "GB"). */
  unit: string;
  /** rate is the cost per unit. */
  rate: number;
  /** setup_version_id is the setup version ID associated with this cost. */
  setupVersionId: string;
  /** quantity is the number of units consumed. */
  quantity: number;
}

/** AddCostRequest is the request message for adding a cost entry. */
export interface AddCostRequest {
  /** cost is the total cost value. */
  cost: number;
  /** mission_id is the mission ID to link this cost to. */
  missionId: string;
  /** name is the descriptive name for this cost. */
  name: string;
  /** cost_type is the classification of the cost. */
  costType: CostType;
  /** unit is the unit of measurement (e.g., "tokens", "calls", "GB"). */
  unit: string;
  /** rate is the cost per unit. */
  rate: number;
  /** setup_version_id is the setup version ID to associate with this cost. */
  setupVersionId: string;
  /** quantity is the number of units consumed. */
  quantity: number;
}

/** AddCostResponse is the response message for adding a cost entry. */
export interface AddCostResponse {
  /** success indicates whether the cost was successfully added. */
  success: boolean;
}

/** CostFilter contains criteria for filtering cost queries. */
export interface CostFilter {
  /** names filters costs by one or more names. */
  names: string[];
  /** cost_types filters costs by cost type classifications. */
  costTypes: CostType[];
  /** setup_version_ids filters costs by setup version IDs. */
  setupVersionIds: string[];
}

/** GetCostsRequest is the request message for retrieving multiple costs. */
export interface GetCostsRequest {
  /** mission_id is the mission ID to query costs for. */
  missionId: string;
  /** filter contains optional filtering criteria. */
  filter?:
    | CostFilter
    | undefined;
  /** limit is the maximum number of costs to return. */
  limit: number;
  /** offset is the number of costs to skip for pagination. */
  offset: number;
}

/** GetCostsResponse is the response message containing multiple costs. */
export interface GetCostsResponse {
  /** costs is the list of matching cost entries. */
  costs: Cost[];
  /** total_count is the total number of costs matching the criteria. */
  totalCount: number;
  /** total_cost is the sum of all matching cost values. */
  totalCost: number;
}

/** GetCostRequest is the request message for retrieving costs by name. */
export interface GetCostRequest {
  /** mission_id is the mission ID to query costs for. */
  missionId: string;
  /** name is the specific cost name to retrieve. */
  name: string;
}

/** GetCostResponse is the response message for cost retrieval by name. */
export interface GetCostResponse {
  /** costs is the list of cost entries matching the name. */
  costs: Cost[];
  /** total_cost is the sum of all matching cost values. */
  totalCost: number;
}

function createBaseCost(): Cost {
  return { cost: 0, missionId: "", name: "", costType: 0, unit: "", rate: 0, setupVersionId: "", quantity: 0 };
}

export const Cost: MessageFns<Cost> = {
  encode(message: Cost, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cost !== 0) {
      writer.uint32(9).double(message.cost);
    }
    if (message.missionId !== "") {
      writer.uint32(18).string(message.missionId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.costType !== 0) {
      writer.uint32(32).int32(message.costType);
    }
    if (message.unit !== "") {
      writer.uint32(42).string(message.unit);
    }
    if (message.rate !== 0) {
      writer.uint32(49).double(message.rate);
    }
    if (message.setupVersionId !== "") {
      writer.uint32(58).string(message.setupVersionId);
    }
    if (message.quantity !== 0) {
      writer.uint32(65).double(message.quantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Cost {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCost();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.cost = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.missionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.costType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.unit = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.rate = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.setupVersionId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.quantity = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Cost {
    return {
      cost: isSet(object.cost) ? globalThis.Number(object.cost) : 0,
      missionId: isSet(object.mission_id) ? globalThis.String(object.mission_id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      costType: isSet(object.cost_type) ? costTypeFromJSON(object.cost_type) : 0,
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
      rate: isSet(object.rate) ? globalThis.Number(object.rate) : 0,
      setupVersionId: isSet(object.setup_version_id) ? globalThis.String(object.setup_version_id) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
    };
  },

  toJSON(message: Cost): unknown {
    const obj: any = {};
    if (message.cost !== 0) {
      obj.cost = message.cost;
    }
    if (message.missionId !== "") {
      obj.mission_id = message.missionId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.costType !== 0) {
      obj.cost_type = costTypeToJSON(message.costType);
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    if (message.rate !== 0) {
      obj.rate = message.rate;
    }
    if (message.setupVersionId !== "") {
      obj.setup_version_id = message.setupVersionId;
    }
    if (message.quantity !== 0) {
      obj.quantity = message.quantity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Cost>, I>>(base?: I): Cost {
    return Cost.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Cost>, I>>(object: I): Cost {
    const message = createBaseCost();
    message.cost = object.cost ?? 0;
    message.missionId = object.missionId ?? "";
    message.name = object.name ?? "";
    message.costType = object.costType ?? 0;
    message.unit = object.unit ?? "";
    message.rate = object.rate ?? 0;
    message.setupVersionId = object.setupVersionId ?? "";
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

function createBaseAddCostRequest(): AddCostRequest {
  return { cost: 0, missionId: "", name: "", costType: 0, unit: "", rate: 0, setupVersionId: "", quantity: 0 };
}

export const AddCostRequest: MessageFns<AddCostRequest> = {
  encode(message: AddCostRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cost !== 0) {
      writer.uint32(9).double(message.cost);
    }
    if (message.missionId !== "") {
      writer.uint32(18).string(message.missionId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.costType !== 0) {
      writer.uint32(32).int32(message.costType);
    }
    if (message.unit !== "") {
      writer.uint32(42).string(message.unit);
    }
    if (message.rate !== 0) {
      writer.uint32(49).double(message.rate);
    }
    if (message.setupVersionId !== "") {
      writer.uint32(58).string(message.setupVersionId);
    }
    if (message.quantity !== 0) {
      writer.uint32(65).double(message.quantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddCostRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddCostRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.cost = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.missionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.costType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.unit = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 49) {
            break;
          }

          message.rate = reader.double();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.setupVersionId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 65) {
            break;
          }

          message.quantity = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddCostRequest {
    return {
      cost: isSet(object.cost) ? globalThis.Number(object.cost) : 0,
      missionId: isSet(object.mission_id) ? globalThis.String(object.mission_id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      costType: isSet(object.cost_type) ? costTypeFromJSON(object.cost_type) : 0,
      unit: isSet(object.unit) ? globalThis.String(object.unit) : "",
      rate: isSet(object.rate) ? globalThis.Number(object.rate) : 0,
      setupVersionId: isSet(object.setup_version_id) ? globalThis.String(object.setup_version_id) : "",
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
    };
  },

  toJSON(message: AddCostRequest): unknown {
    const obj: any = {};
    if (message.cost !== 0) {
      obj.cost = message.cost;
    }
    if (message.missionId !== "") {
      obj.mission_id = message.missionId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.costType !== 0) {
      obj.cost_type = costTypeToJSON(message.costType);
    }
    if (message.unit !== "") {
      obj.unit = message.unit;
    }
    if (message.rate !== 0) {
      obj.rate = message.rate;
    }
    if (message.setupVersionId !== "") {
      obj.setup_version_id = message.setupVersionId;
    }
    if (message.quantity !== 0) {
      obj.quantity = message.quantity;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddCostRequest>, I>>(base?: I): AddCostRequest {
    return AddCostRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddCostRequest>, I>>(object: I): AddCostRequest {
    const message = createBaseAddCostRequest();
    message.cost = object.cost ?? 0;
    message.missionId = object.missionId ?? "";
    message.name = object.name ?? "";
    message.costType = object.costType ?? 0;
    message.unit = object.unit ?? "";
    message.rate = object.rate ?? 0;
    message.setupVersionId = object.setupVersionId ?? "";
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

function createBaseAddCostResponse(): AddCostResponse {
  return { success: false };
}

export const AddCostResponse: MessageFns<AddCostResponse> = {
  encode(message: AddCostResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddCostResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddCostResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddCostResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: AddCostResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddCostResponse>, I>>(base?: I): AddCostResponse {
    return AddCostResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddCostResponse>, I>>(object: I): AddCostResponse {
    const message = createBaseAddCostResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseCostFilter(): CostFilter {
  return { names: [], costTypes: [], setupVersionIds: [] };
}

export const CostFilter: MessageFns<CostFilter> = {
  encode(message: CostFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.names) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.costTypes) {
      writer.uint32(16).int32(v!);
    }
    for (const v of message.setupVersionIds) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CostFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCostFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.names.push(reader.string());
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.costTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.costTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.setupVersionIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CostFilter {
    return {
      names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [],
      costTypes: globalThis.Array.isArray(object?.cost_types)
        ? object.cost_types.map((e: any) => costTypeFromJSON(e))
        : [],
      setupVersionIds: globalThis.Array.isArray(object?.setup_version_ids)
        ? object.setup_version_ids.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: CostFilter): unknown {
    const obj: any = {};
    if (message.names?.length) {
      obj.names = message.names;
    }
    if (message.costTypes?.length) {
      obj.cost_types = message.costTypes.map((e) => costTypeToJSON(e));
    }
    if (message.setupVersionIds?.length) {
      obj.setup_version_ids = message.setupVersionIds;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CostFilter>, I>>(base?: I): CostFilter {
    return CostFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CostFilter>, I>>(object: I): CostFilter {
    const message = createBaseCostFilter();
    message.names = object.names?.map((e) => e) || [];
    message.costTypes = object.costTypes?.map((e) => e) || [];
    message.setupVersionIds = object.setupVersionIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetCostsRequest(): GetCostsRequest {
  return { missionId: "", filter: undefined, limit: 0, offset: 0 };
}

export const GetCostsRequest: MessageFns<GetCostsRequest> = {
  encode(message: GetCostsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.missionId !== "") {
      writer.uint32(10).string(message.missionId);
    }
    if (message.filter !== undefined) {
      CostFilter.encode(message.filter, writer.uint32(18).fork()).join();
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(32).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCostsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCostsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.missionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filter = CostFilter.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCostsRequest {
    return {
      missionId: isSet(object.mission_id) ? globalThis.String(object.mission_id) : "",
      filter: isSet(object.filter) ? CostFilter.fromJSON(object.filter) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: GetCostsRequest): unknown {
    const obj: any = {};
    if (message.missionId !== "") {
      obj.mission_id = message.missionId;
    }
    if (message.filter !== undefined) {
      obj.filter = CostFilter.toJSON(message.filter);
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCostsRequest>, I>>(base?: I): GetCostsRequest {
    return GetCostsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCostsRequest>, I>>(object: I): GetCostsRequest {
    const message = createBaseGetCostsRequest();
    message.missionId = object.missionId ?? "";
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? CostFilter.fromPartial(object.filter)
      : undefined;
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseGetCostsResponse(): GetCostsResponse {
  return { costs: [], totalCount: 0, totalCost: 0 };
}

export const GetCostsResponse: MessageFns<GetCostsResponse> = {
  encode(message: GetCostsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.costs) {
      Cost.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.totalCost !== 0) {
      writer.uint32(25).double(message.totalCost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCostsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCostsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.costs.push(Cost.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.totalCost = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCostsResponse {
    return {
      costs: globalThis.Array.isArray(object?.costs) ? object.costs.map((e: any) => Cost.fromJSON(e)) : [],
      totalCount: isSet(object.total_count) ? globalThis.Number(object.total_count) : 0,
      totalCost: isSet(object.total_cost) ? globalThis.Number(object.total_cost) : 0,
    };
  },

  toJSON(message: GetCostsResponse): unknown {
    const obj: any = {};
    if (message.costs?.length) {
      obj.costs = message.costs.map((e) => Cost.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.total_count = Math.round(message.totalCount);
    }
    if (message.totalCost !== 0) {
      obj.total_cost = message.totalCost;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCostsResponse>, I>>(base?: I): GetCostsResponse {
    return GetCostsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCostsResponse>, I>>(object: I): GetCostsResponse {
    const message = createBaseGetCostsResponse();
    message.costs = object.costs?.map((e) => Cost.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.totalCost = object.totalCost ?? 0;
    return message;
  },
};

function createBaseGetCostRequest(): GetCostRequest {
  return { missionId: "", name: "" };
}

export const GetCostRequest: MessageFns<GetCostRequest> = {
  encode(message: GetCostRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.missionId !== "") {
      writer.uint32(10).string(message.missionId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCostRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCostRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.missionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCostRequest {
    return {
      missionId: isSet(object.mission_id) ? globalThis.String(object.mission_id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
    };
  },

  toJSON(message: GetCostRequest): unknown {
    const obj: any = {};
    if (message.missionId !== "") {
      obj.mission_id = message.missionId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCostRequest>, I>>(base?: I): GetCostRequest {
    return GetCostRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCostRequest>, I>>(object: I): GetCostRequest {
    const message = createBaseGetCostRequest();
    message.missionId = object.missionId ?? "";
    message.name = object.name ?? "";
    return message;
  },
};

function createBaseGetCostResponse(): GetCostResponse {
  return { costs: [], totalCost: 0 };
}

export const GetCostResponse: MessageFns<GetCostResponse> = {
  encode(message: GetCostResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.costs) {
      Cost.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCost !== 0) {
      writer.uint32(17).double(message.totalCost);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCostResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCostResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.costs.push(Cost.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.totalCost = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetCostResponse {
    return {
      costs: globalThis.Array.isArray(object?.costs) ? object.costs.map((e: any) => Cost.fromJSON(e)) : [],
      totalCost: isSet(object.total_cost) ? globalThis.Number(object.total_cost) : 0,
    };
  },

  toJSON(message: GetCostResponse): unknown {
    const obj: any = {};
    if (message.costs?.length) {
      obj.costs = message.costs.map((e) => Cost.toJSON(e));
    }
    if (message.totalCost !== 0) {
      obj.total_cost = message.totalCost;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetCostResponse>, I>>(base?: I): GetCostResponse {
    return GetCostResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetCostResponse>, I>>(object: I): GetCostResponse {
    const message = createBaseGetCostResponse();
    message.costs = object.costs?.map((e) => Cost.fromPartial(e)) || [];
    message.totalCost = object.totalCost ?? 0;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
