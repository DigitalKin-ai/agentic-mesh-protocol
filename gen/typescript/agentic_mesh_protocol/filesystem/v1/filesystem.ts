// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               unknown
// source: agentic_mesh_protocol/filesystem/v1/filesystem.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Struct } from "../../../google/protobuf/struct.js";
import { Timestamp } from "../../../google/protobuf/timestamp.js";

export const protobufPackage = "agentic_mesh_protocol.filesystem.v1";

/** FileType represents the classification of file types in the system. */
export enum FileType {
  /** FILE_TYPE_UNSPECIFIED - FILE_TYPE_UNSPECIFIED is the default unspecified value. */
  FILE_TYPE_UNSPECIFIED = 0,
  /** FILE_TYPE_DOCUMENT - FILE_TYPE_DOCUMENT represents document files (PDF, DOC, TXT, etc.). */
  FILE_TYPE_DOCUMENT = 1,
  /** FILE_TYPE_IMAGE - FILE_TYPE_IMAGE represents image files (PNG, JPG, GIF, etc.). */
  FILE_TYPE_IMAGE = 2,
  /** FILE_TYPE_VIDEO - FILE_TYPE_VIDEO represents video files (MP4, AVI, MOV, etc.). */
  FILE_TYPE_VIDEO = 3,
  /** FILE_TYPE_AUDIO - FILE_TYPE_AUDIO represents audio files (MP3, WAV, etc.). */
  FILE_TYPE_AUDIO = 4,
  /** FILE_TYPE_ARCHIVE - FILE_TYPE_ARCHIVE represents archive files (ZIP, TAR, etc.). */
  FILE_TYPE_ARCHIVE = 5,
  /** FILE_TYPE_CODE - FILE_TYPE_CODE represents source code files. */
  FILE_TYPE_CODE = 6,
  /** FILE_TYPE_OTHER - FILE_TYPE_OTHER represents other file types. */
  FILE_TYPE_OTHER = 7,
  UNRECOGNIZED = -1,
}

export function fileTypeFromJSON(object: any): FileType {
  switch (object) {
    case 0:
    case "FILE_TYPE_UNSPECIFIED":
      return FileType.FILE_TYPE_UNSPECIFIED;
    case 1:
    case "FILE_TYPE_DOCUMENT":
      return FileType.FILE_TYPE_DOCUMENT;
    case 2:
    case "FILE_TYPE_IMAGE":
      return FileType.FILE_TYPE_IMAGE;
    case 3:
    case "FILE_TYPE_VIDEO":
      return FileType.FILE_TYPE_VIDEO;
    case 4:
    case "FILE_TYPE_AUDIO":
      return FileType.FILE_TYPE_AUDIO;
    case 5:
    case "FILE_TYPE_ARCHIVE":
      return FileType.FILE_TYPE_ARCHIVE;
    case 6:
    case "FILE_TYPE_CODE":
      return FileType.FILE_TYPE_CODE;
    case 7:
    case "FILE_TYPE_OTHER":
      return FileType.FILE_TYPE_OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FileType.UNRECOGNIZED;
  }
}

export function fileTypeToJSON(object: FileType): string {
  switch (object) {
    case FileType.FILE_TYPE_UNSPECIFIED:
      return "FILE_TYPE_UNSPECIFIED";
    case FileType.FILE_TYPE_DOCUMENT:
      return "FILE_TYPE_DOCUMENT";
    case FileType.FILE_TYPE_IMAGE:
      return "FILE_TYPE_IMAGE";
    case FileType.FILE_TYPE_VIDEO:
      return "FILE_TYPE_VIDEO";
    case FileType.FILE_TYPE_AUDIO:
      return "FILE_TYPE_AUDIO";
    case FileType.FILE_TYPE_ARCHIVE:
      return "FILE_TYPE_ARCHIVE";
    case FileType.FILE_TYPE_CODE:
      return "FILE_TYPE_CODE";
    case FileType.FILE_TYPE_OTHER:
      return "FILE_TYPE_OTHER";
    case FileType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** FileStatus represents the lifecycle status of a file in the system. */
export enum FileStatus {
  /** FILE_STATUS_UNSPECIFIED - FILE_STATUS_UNSPECIFIED is the default unspecified value. */
  FILE_STATUS_UNSPECIFIED = 0,
  /** FILE_STATUS_UPLOADING - FILE_STATUS_UPLOADING indicates the file is currently being uploaded. */
  FILE_STATUS_UPLOADING = 1,
  /** FILE_STATUS_ACTIVE - FILE_STATUS_ACTIVE indicates the file is active and available for use. */
  FILE_STATUS_ACTIVE = 2,
  /** FILE_STATUS_PROCESSING - FILE_STATUS_PROCESSING indicates the file is being processed. */
  FILE_STATUS_PROCESSING = 3,
  /** FILE_STATUS_ARCHIVED - FILE_STATUS_ARCHIVED indicates the file has been archived. */
  FILE_STATUS_ARCHIVED = 4,
  /** FILE_STATUS_DELETED - FILE_STATUS_DELETED indicates the file is marked for deletion. */
  FILE_STATUS_DELETED = 5,
  UNRECOGNIZED = -1,
}

export function fileStatusFromJSON(object: any): FileStatus {
  switch (object) {
    case 0:
    case "FILE_STATUS_UNSPECIFIED":
      return FileStatus.FILE_STATUS_UNSPECIFIED;
    case 1:
    case "FILE_STATUS_UPLOADING":
      return FileStatus.FILE_STATUS_UPLOADING;
    case 2:
    case "FILE_STATUS_ACTIVE":
      return FileStatus.FILE_STATUS_ACTIVE;
    case 3:
    case "FILE_STATUS_PROCESSING":
      return FileStatus.FILE_STATUS_PROCESSING;
    case 4:
    case "FILE_STATUS_ARCHIVED":
      return FileStatus.FILE_STATUS_ARCHIVED;
    case 5:
    case "FILE_STATUS_DELETED":
      return FileStatus.FILE_STATUS_DELETED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FileStatus.UNRECOGNIZED;
  }
}

export function fileStatusToJSON(object: FileStatus): string {
  switch (object) {
    case FileStatus.FILE_STATUS_UNSPECIFIED:
      return "FILE_STATUS_UNSPECIFIED";
    case FileStatus.FILE_STATUS_UPLOADING:
      return "FILE_STATUS_UPLOADING";
    case FileStatus.FILE_STATUS_ACTIVE:
      return "FILE_STATUS_ACTIVE";
    case FileStatus.FILE_STATUS_PROCESSING:
      return "FILE_STATUS_PROCESSING";
    case FileStatus.FILE_STATUS_ARCHIVED:
      return "FILE_STATUS_ARCHIVED";
    case FileStatus.FILE_STATUS_DELETED:
      return "FILE_STATUS_DELETED";
    case FileStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** File represents a stored file with comprehensive metadata. */
export interface File {
  /** file_id: Unique identifier for the file (UUID) */
  fileId: string;
  /** context: Context ID linked to the file */
  context: string;
  /** name: Name of the file (unique within context) */
  name: string;
  /** file_type: Type classification of the file */
  fileType: FileType;
  /** content_type: MIME type of the file */
  contentType: string;
  /** size_bytes: Size of the file in bytes */
  sizeBytes: string;
  /** checksum: SHA-256 checksum of the file content (SHA-256 format) */
  checksum: string;
  /** metadata: Flexible metadata for additional file properties */
  metadata?:
    | { [key: string]: any }
    | undefined;
  /** storage_uri: Internal URI for accessing the file content */
  storageUri: string;
  /** file_url: External URL for accessing the file content */
  fileUrl: string;
  /** status: Current status of the file */
  status: FileStatus;
  /** content: The content of the file */
  content: Buffer;
}

/** FileFilter contains criteria for querying and filtering files. */
export interface FileFilter {
  /** names: Filter by file names (exact matches) */
  names: string[];
  /** file_ids: Filter by file IDs */
  fileIds: string[];
  /** file_types: Filter by file types */
  fileTypes: FileType[];
  /** context: Filter by context (required for scoping) */
  context: string;
  /** created_after: Filter files created after this timestamp */
  createdAfter?:
    | Date
    | undefined;
  /** created_before: Filter files created before this timestamp */
  createdBefore?:
    | Date
    | undefined;
  /** updated_after: Filter files updated after this timestamp */
  updatedAfter?:
    | Date
    | undefined;
  /** updated_before: Filter files updated before this timestamp */
  updatedBefore?:
    | Date
    | undefined;
  /** status: Filter by file status */
  status: FileStatus;
  /** content_type_prefix: Filter by content type prefix (e.g., "image/") */
  contentTypePrefix: string;
  /** min_size_bytes: Filter files with minimum size */
  minSizeBytes: string;
  /** max_size_bytes: Filter files with maximum size */
  maxSizeBytes: string;
  /** prefix: Filter by path prefix (e.g., "folder1/") */
  prefix: string;
  /** content_type: Filter by content type */
  contentType: string;
}

/** FileResult wraps the result of a file operation which may succeed or fail. */
export interface FileResult {
  /** file: Successfully processed file */
  file?:
    | File
    | undefined;
  /** error: Error information if operation failed */
  error?: string | undefined;
}

/** UploadFileData contains the data required for uploading a single file. */
export interface UploadFileData {
  /** context: Context ID for the file */
  context: string;
  /** name: Name of the file */
  name: string;
  /** file_type: Type classification of the file */
  fileType: FileType;
  /** content_type: MIME type of the file */
  contentType: string;
  /** content: File content */
  content: Buffer;
  /** metadata: Additional metadata for the file */
  metadata?:
    | { [key: string]: any }
    | undefined;
  /** status: Status of the file */
  status: FileStatus;
  /** replace_if_exists: Whether to replace existing file with same name */
  replaceIfExists: boolean;
}

/** UploadFilesRequest is the request message for uploading multiple files. */
export interface UploadFilesRequest {
  /** files: List of files to upload */
  files: UploadFileData[];
}

/** UploadFilesResponse is the response message for file upload operations. */
export interface UploadFilesResponse {
  /** results: Results for each uploaded file */
  results: FileResult[];
  /** total_uploaded: Number of successfully uploaded files */
  totalUploaded: number;
  /** total_failed: Number of failed uploads */
  totalFailed: number;
}

/** GetFileRequest is the request message for retrieving a specific file. */
export interface GetFileRequest {
  /** context: Context ID for the file */
  context: string;
  /** file_id: File ID */
  fileId: string;
  /** include_content: Whether to include file content in response */
  includeContent: boolean;
}

/** GetFileResponse is the response message containing file information. */
export interface GetFileResponse {
  /** file: The requested file */
  file?:
    | File
    | undefined;
  /** content: File content (only if requested) */
  content: Buffer;
}

/** UpdateFileRequest is the request message for updating a file. */
export interface UpdateFileRequest {
  /** context: Context ID for the file */
  context: string;
  /** file_id: Current id of the file */
  fileId: string;
  /** new_name: New name for the file (optional) */
  newName: string;
  /** file_type: New file type (optional, cannot be UNSPECIFIED) */
  fileType: FileType;
  /** content_type: New content type (optional) */
  contentType: string;
  /** content: New file content (optional) */
  content: Buffer;
  /** status: New status of the file */
  status: FileStatus;
  /** metadata: New metadata (optional, will merge with existing) */
  metadata?: { [key: string]: any } | undefined;
}

/** UpdateFileResponse is the response message for file update operations. */
export interface UpdateFileResponse {
  /** result: Result of the file update operation */
  result?: FileResult | undefined;
}

/** GetFilesRequest is the request message for retrieving multiple files by various criteria. */
export interface GetFilesRequest {
  /** context: Context ID for the files */
  context: string;
  /** filters: How to identify the files */
  filters?:
    | FileFilter
    | undefined;
  /** list_size: Number of files to return per page */
  listSize: number;
  /** offset: Offset of the first file in the list */
  offset: number;
  /** order: Field to order results by */
  order: string;
  /** include_content: Whether to include file content in response */
  includeContent: boolean;
}

/** GetFilesResponse is the response message containing multiple files. */
export interface GetFilesResponse {
  /** files: List of files matching the criteria */
  files: File[];
  /** total_count: Total number of files matching the criteria */
  totalCount: number;
}

/** DeleteFilesRequest is the request message for deleting multiple files. */
export interface DeleteFilesRequest {
  /** context: Context ID for the files */
  context: string;
  /** filters: How to identify the files */
  filters?:
    | FileFilter
    | undefined;
  /** force: Whether to force delete even if file is in use */
  force: boolean;
  /** permanent: Whether to permanently delete (vs mark as deleted) */
  permanent: boolean;
}

/** DeleteFilesResponse is the response message for file deletion operations. */
export interface DeleteFilesResponse {
  /** results: Results for each file deletion attempt */
  results: { [key: string]: boolean };
  /** total_deleted: Number of successfully deleted files */
  totalDeleted: number;
  /** total_failed: Number of failed deletions */
  totalFailed: number;
}

export interface DeleteFilesResponse_ResultsEntry {
  key: string;
  value: boolean;
}

function createBaseFile(): File {
  return {
    fileId: "",
    context: "",
    name: "",
    fileType: 0,
    contentType: "",
    sizeBytes: "0",
    checksum: "",
    metadata: undefined,
    storageUri: "",
    fileUrl: "",
    status: 0,
    content: Buffer.alloc(0),
  };
}

export const File: MessageFns<File> = {
  encode(message: File, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fileId !== "") {
      writer.uint32(10).string(message.fileId);
    }
    if (message.context !== "") {
      writer.uint32(18).string(message.context);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.fileType !== 0) {
      writer.uint32(32).int32(message.fileType);
    }
    if (message.contentType !== "") {
      writer.uint32(42).string(message.contentType);
    }
    if (message.sizeBytes !== "0") {
      writer.uint32(48).int64(message.sizeBytes);
    }
    if (message.checksum !== "") {
      writer.uint32(58).string(message.checksum);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(66).fork()).join();
    }
    if (message.storageUri !== "") {
      writer.uint32(74).string(message.storageUri);
    }
    if (message.fileUrl !== "") {
      writer.uint32(82).string(message.fileUrl);
    }
    if (message.status !== 0) {
      writer.uint32(88).int32(message.status);
    }
    if (message.content.length !== 0) {
      writer.uint32(98).bytes(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): File {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fileId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.context = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fileType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sizeBytes = reader.int64().toString();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.storageUri = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.fileUrl = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.content = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): File {
    return {
      fileId: isSet(object.file_id) ? globalThis.String(object.file_id) : "",
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fileType: isSet(object.file_type) ? fileTypeFromJSON(object.file_type) : 0,
      contentType: isSet(object.content_type) ? globalThis.String(object.content_type) : "",
      sizeBytes: isSet(object.size_bytes) ? globalThis.String(object.size_bytes) : "0",
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      storageUri: isSet(object.storage_uri) ? globalThis.String(object.storage_uri) : "",
      fileUrl: isSet(object.file_url) ? globalThis.String(object.file_url) : "",
      status: isSet(object.status) ? fileStatusFromJSON(object.status) : 0,
      content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : Buffer.alloc(0),
    };
  },

  toJSON(message: File): unknown {
    const obj: any = {};
    if (message.fileId !== "") {
      obj.file_id = message.fileId;
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fileType !== 0) {
      obj.file_type = fileTypeToJSON(message.fileType);
    }
    if (message.contentType !== "") {
      obj.content_type = message.contentType;
    }
    if (message.sizeBytes !== "0") {
      obj.size_bytes = message.sizeBytes;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.storageUri !== "") {
      obj.storage_uri = message.storageUri;
    }
    if (message.fileUrl !== "") {
      obj.file_url = message.fileUrl;
    }
    if (message.status !== 0) {
      obj.status = fileStatusToJSON(message.status);
    }
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<File>, I>>(base?: I): File {
    return File.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<File>, I>>(object: I): File {
    const message = createBaseFile();
    message.fileId = object.fileId ?? "";
    message.context = object.context ?? "";
    message.name = object.name ?? "";
    message.fileType = object.fileType ?? 0;
    message.contentType = object.contentType ?? "";
    message.sizeBytes = object.sizeBytes ?? "0";
    message.checksum = object.checksum ?? "";
    message.metadata = object.metadata ?? undefined;
    message.storageUri = object.storageUri ?? "";
    message.fileUrl = object.fileUrl ?? "";
    message.status = object.status ?? 0;
    message.content = object.content ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseFileFilter(): FileFilter {
  return {
    names: [],
    fileIds: [],
    fileTypes: [],
    context: "",
    createdAfter: undefined,
    createdBefore: undefined,
    updatedAfter: undefined,
    updatedBefore: undefined,
    status: 0,
    contentTypePrefix: "",
    minSizeBytes: "0",
    maxSizeBytes: "0",
    prefix: "",
    contentType: "",
  };
}

export const FileFilter: MessageFns<FileFilter> = {
  encode(message: FileFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.names) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.fileIds) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.fileTypes) {
      writer.uint32(24).int32(v!);
    }
    if (message.context !== "") {
      writer.uint32(34).string(message.context);
    }
    if (message.createdAfter !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAfter), writer.uint32(42).fork()).join();
    }
    if (message.createdBefore !== undefined) {
      Timestamp.encode(toTimestamp(message.createdBefore), writer.uint32(50).fork()).join();
    }
    if (message.updatedAfter !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAfter), writer.uint32(58).fork()).join();
    }
    if (message.updatedBefore !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedBefore), writer.uint32(66).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(72).int32(message.status);
    }
    if (message.contentTypePrefix !== "") {
      writer.uint32(82).string(message.contentTypePrefix);
    }
    if (message.minSizeBytes !== "0") {
      writer.uint32(88).int64(message.minSizeBytes);
    }
    if (message.maxSizeBytes !== "0") {
      writer.uint32(96).int64(message.maxSizeBytes);
    }
    if (message.prefix !== "") {
      writer.uint32(106).string(message.prefix);
    }
    if (message.contentType !== "") {
      writer.uint32(114).string(message.contentType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.names.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileIds.push(reader.string());
          continue;
        }
        case 3: {
          if (tag === 24) {
            message.fileTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.fileTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.context = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAfter = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdBefore = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.updatedAfter = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.updatedBefore = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.contentTypePrefix = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.minSizeBytes = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.maxSizeBytes = reader.int64().toString();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileFilter {
    return {
      names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [],
      fileIds: globalThis.Array.isArray(object?.file_ids) ? object.file_ids.map((e: any) => globalThis.String(e)) : [],
      fileTypes: globalThis.Array.isArray(object?.file_types)
        ? object.file_types.map((e: any) => fileTypeFromJSON(e))
        : [],
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      createdAfter: isSet(object.created_after) ? fromJsonTimestamp(object.created_after) : undefined,
      createdBefore: isSet(object.created_before) ? fromJsonTimestamp(object.created_before) : undefined,
      updatedAfter: isSet(object.updated_after) ? fromJsonTimestamp(object.updated_after) : undefined,
      updatedBefore: isSet(object.updated_before) ? fromJsonTimestamp(object.updated_before) : undefined,
      status: isSet(object.status) ? fileStatusFromJSON(object.status) : 0,
      contentTypePrefix: isSet(object.content_type_prefix) ? globalThis.String(object.content_type_prefix) : "",
      minSizeBytes: isSet(object.min_size_bytes) ? globalThis.String(object.min_size_bytes) : "0",
      maxSizeBytes: isSet(object.max_size_bytes) ? globalThis.String(object.max_size_bytes) : "0",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : "",
      contentType: isSet(object.content_type) ? globalThis.String(object.content_type) : "",
    };
  },

  toJSON(message: FileFilter): unknown {
    const obj: any = {};
    if (message.names?.length) {
      obj.names = message.names;
    }
    if (message.fileIds?.length) {
      obj.file_ids = message.fileIds;
    }
    if (message.fileTypes?.length) {
      obj.file_types = message.fileTypes.map((e) => fileTypeToJSON(e));
    }
    if (message.context !== "") {
      obj.context = message.context;
    }
    if (message.createdAfter !== undefined) {
      obj.created_after = message.createdAfter.toISOString();
    }
    if (message.createdBefore !== undefined) {
      obj.created_before = message.createdBefore.toISOString();
    }
    if (message.updatedAfter !== undefined) {
      obj.updated_after = message.updatedAfter.toISOString();
    }
    if (message.updatedBefore !== undefined) {
      obj.updated_before = message.updatedBefore.toISOString();
    }
    if (message.status !== 0) {
      obj.status = fileStatusToJSON(message.status);
    }
    if (message.contentTypePrefix !== "") {
      obj.content_type_prefix = message.contentTypePrefix;
    }
    if (message.minSizeBytes !== "0") {
      obj.min_size_bytes = message.minSizeBytes;
    }
    if (message.maxSizeBytes !== "0") {
      obj.max_size_bytes = message.maxSizeBytes;
    }
    if (message.prefix !== "") {
      obj.prefix = message.prefix;
    }
    if (message.contentType !== "") {
      obj.content_type = message.contentType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileFilter>, I>>(base?: I): FileFilter {
    return FileFilter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileFilter>, I>>(object: I): FileFilter {
    const message = createBaseFileFilter();
    message.names = object.names?.map((e) => e) || [];
    message.fileIds = object.fileIds?.map((e) => e) || [];
    message.fileTypes = object.fileTypes?.map((e) => e) || [];
    message.context = object.context ?? "";
    message.createdAfter = object.createdAfter ?? undefined;
    message.createdBefore = object.createdBefore ?? undefined;
    message.updatedAfter = object.updatedAfter ?? undefined;
    message.updatedBefore = object.updatedBefore ?? undefined;
    message.status = object.status ?? 0;
    message.contentTypePrefix = object.contentTypePrefix ?? "";
    message.minSizeBytes = object.minSizeBytes ?? "0";
    message.maxSizeBytes = object.maxSizeBytes ?? "0";
    message.prefix = object.prefix ?? "";
    message.contentType = object.contentType ?? "";
    return message;
  },
};

function createBaseFileResult(): FileResult {
  return { file: undefined, error: undefined };
}

export const FileResult: MessageFns<FileResult> = {
  encode(message: FileResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.file !== undefined) {
      File.encode(message.file, writer.uint32(10).fork()).join();
    }
    if (message.error !== undefined) {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.file = File.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileResult {
    return {
      file: isSet(object.file) ? File.fromJSON(object.file) : undefined,
      error: isSet(object.error) ? globalThis.String(object.error) : undefined,
    };
  },

  toJSON(message: FileResult): unknown {
    const obj: any = {};
    if (message.file !== undefined) {
      obj.file = File.toJSON(message.file);
    }
    if (message.error !== undefined) {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileResult>, I>>(base?: I): FileResult {
    return FileResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileResult>, I>>(object: I): FileResult {
    const message = createBaseFileResult();
    message.file = (object.file !== undefined && object.file !== null) ? File.fromPartial(object.file) : undefined;
    message.error = object.error ?? undefined;
    return message;
  },
};

function createBaseUploadFileData(): UploadFileData {
  return {
    context: "",
    name: "",
    fileType: 0,
    contentType: "",
    content: Buffer.alloc(0),
    metadata: undefined,
    status: 0,
    replaceIfExists: false,
  };
}

export const UploadFileData: MessageFns<UploadFileData> = {
  encode(message: UploadFileData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== "") {
      writer.uint32(10).string(message.context);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.fileType !== 0) {
      writer.uint32(24).int32(message.fileType);
    }
    if (message.contentType !== "") {
      writer.uint32(34).string(message.contentType);
    }
    if (message.content.length !== 0) {
      writer.uint32(42).bytes(message.content);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(50).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(56).int32(message.status);
    }
    if (message.replaceIfExists !== false) {
      writer.uint32(64).bool(message.replaceIfExists);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadFileData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadFileData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.context = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.fileType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.content = Buffer.from(reader.bytes());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.replaceIfExists = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadFileData {
    return {
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      fileType: isSet(object.file_type) ? fileTypeFromJSON(object.file_type) : 0,
      contentType: isSet(object.content_type) ? globalThis.String(object.content_type) : "",
      content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : Buffer.alloc(0),
      metadata: isObject(object.metadata) ? object.metadata : undefined,
      status: isSet(object.status) ? fileStatusFromJSON(object.status) : 0,
      replaceIfExists: isSet(object.replace_if_exists) ? globalThis.Boolean(object.replace_if_exists) : false,
    };
  },

  toJSON(message: UploadFileData): unknown {
    const obj: any = {};
    if (message.context !== "") {
      obj.context = message.context;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.fileType !== 0) {
      obj.file_type = fileTypeToJSON(message.fileType);
    }
    if (message.contentType !== "") {
      obj.content_type = message.contentType;
    }
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.status !== 0) {
      obj.status = fileStatusToJSON(message.status);
    }
    if (message.replaceIfExists !== false) {
      obj.replace_if_exists = message.replaceIfExists;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadFileData>, I>>(base?: I): UploadFileData {
    return UploadFileData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadFileData>, I>>(object: I): UploadFileData {
    const message = createBaseUploadFileData();
    message.context = object.context ?? "";
    message.name = object.name ?? "";
    message.fileType = object.fileType ?? 0;
    message.contentType = object.contentType ?? "";
    message.content = object.content ?? Buffer.alloc(0);
    message.metadata = object.metadata ?? undefined;
    message.status = object.status ?? 0;
    message.replaceIfExists = object.replaceIfExists ?? false;
    return message;
  },
};

function createBaseUploadFilesRequest(): UploadFilesRequest {
  return { files: [] };
}

export const UploadFilesRequest: MessageFns<UploadFilesRequest> = {
  encode(message: UploadFilesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.files) {
      UploadFileData.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadFilesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadFilesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.files.push(UploadFileData.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadFilesRequest {
    return {
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => UploadFileData.fromJSON(e)) : [],
    };
  },

  toJSON(message: UploadFilesRequest): unknown {
    const obj: any = {};
    if (message.files?.length) {
      obj.files = message.files.map((e) => UploadFileData.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadFilesRequest>, I>>(base?: I): UploadFilesRequest {
    return UploadFilesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadFilesRequest>, I>>(object: I): UploadFilesRequest {
    const message = createBaseUploadFilesRequest();
    message.files = object.files?.map((e) => UploadFileData.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUploadFilesResponse(): UploadFilesResponse {
  return { results: [], totalUploaded: 0, totalFailed: 0 };
}

export const UploadFilesResponse: MessageFns<UploadFilesResponse> = {
  encode(message: UploadFilesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      FileResult.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalUploaded !== 0) {
      writer.uint32(16).int32(message.totalUploaded);
    }
    if (message.totalFailed !== 0) {
      writer.uint32(24).int32(message.totalFailed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadFilesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadFilesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(FileResult.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalUploaded = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalFailed = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadFilesResponse {
    return {
      results: globalThis.Array.isArray(object?.results) ? object.results.map((e: any) => FileResult.fromJSON(e)) : [],
      totalUploaded: isSet(object.total_uploaded) ? globalThis.Number(object.total_uploaded) : 0,
      totalFailed: isSet(object.total_failed) ? globalThis.Number(object.total_failed) : 0,
    };
  },

  toJSON(message: UploadFilesResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => FileResult.toJSON(e));
    }
    if (message.totalUploaded !== 0) {
      obj.total_uploaded = Math.round(message.totalUploaded);
    }
    if (message.totalFailed !== 0) {
      obj.total_failed = Math.round(message.totalFailed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UploadFilesResponse>, I>>(base?: I): UploadFilesResponse {
    return UploadFilesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UploadFilesResponse>, I>>(object: I): UploadFilesResponse {
    const message = createBaseUploadFilesResponse();
    message.results = object.results?.map((e) => FileResult.fromPartial(e)) || [];
    message.totalUploaded = object.totalUploaded ?? 0;
    message.totalFailed = object.totalFailed ?? 0;
    return message;
  },
};

function createBaseGetFileRequest(): GetFileRequest {
  return { context: "", fileId: "", includeContent: false };
}

export const GetFileRequest: MessageFns<GetFileRequest> = {
  encode(message: GetFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== "") {
      writer.uint32(10).string(message.context);
    }
    if (message.fileId !== "") {
      writer.uint32(18).string(message.fileId);
    }
    if (message.includeContent !== false) {
      writer.uint32(24).bool(message.includeContent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.context = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeContent = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFileRequest {
    return {
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      fileId: isSet(object.file_id) ? globalThis.String(object.file_id) : "",
      includeContent: isSet(object.include_content) ? globalThis.Boolean(object.include_content) : false,
    };
  },

  toJSON(message: GetFileRequest): unknown {
    const obj: any = {};
    if (message.context !== "") {
      obj.context = message.context;
    }
    if (message.fileId !== "") {
      obj.file_id = message.fileId;
    }
    if (message.includeContent !== false) {
      obj.include_content = message.includeContent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFileRequest>, I>>(base?: I): GetFileRequest {
    return GetFileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFileRequest>, I>>(object: I): GetFileRequest {
    const message = createBaseGetFileRequest();
    message.context = object.context ?? "";
    message.fileId = object.fileId ?? "";
    message.includeContent = object.includeContent ?? false;
    return message;
  },
};

function createBaseGetFileResponse(): GetFileResponse {
  return { file: undefined, content: Buffer.alloc(0) };
}

export const GetFileResponse: MessageFns<GetFileResponse> = {
  encode(message: GetFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.file !== undefined) {
      File.encode(message.file, writer.uint32(10).fork()).join();
    }
    if (message.content.length !== 0) {
      writer.uint32(18).bytes(message.content);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.file = File.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFileResponse {
    return {
      file: isSet(object.file) ? File.fromJSON(object.file) : undefined,
      content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : Buffer.alloc(0),
    };
  },

  toJSON(message: GetFileResponse): unknown {
    const obj: any = {};
    if (message.file !== undefined) {
      obj.file = File.toJSON(message.file);
    }
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFileResponse>, I>>(base?: I): GetFileResponse {
    return GetFileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFileResponse>, I>>(object: I): GetFileResponse {
    const message = createBaseGetFileResponse();
    message.file = (object.file !== undefined && object.file !== null) ? File.fromPartial(object.file) : undefined;
    message.content = object.content ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseUpdateFileRequest(): UpdateFileRequest {
  return {
    context: "",
    fileId: "",
    newName: "",
    fileType: 0,
    contentType: "",
    content: Buffer.alloc(0),
    status: 0,
    metadata: undefined,
  };
}

export const UpdateFileRequest: MessageFns<UpdateFileRequest> = {
  encode(message: UpdateFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== "") {
      writer.uint32(10).string(message.context);
    }
    if (message.fileId !== "") {
      writer.uint32(18).string(message.fileId);
    }
    if (message.newName !== "") {
      writer.uint32(26).string(message.newName);
    }
    if (message.fileType !== 0) {
      writer.uint32(32).int32(message.fileType);
    }
    if (message.contentType !== "") {
      writer.uint32(42).string(message.contentType);
    }
    if (message.content.length !== 0) {
      writer.uint32(50).bytes(message.content);
    }
    if (message.status !== 0) {
      writer.uint32(56).int32(message.status);
    }
    if (message.metadata !== undefined) {
      Struct.encode(Struct.wrap(message.metadata), writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.context = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.fileType = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.content = Buffer.from(reader.bytes());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.metadata = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFileRequest {
    return {
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      fileId: isSet(object.file_id) ? globalThis.String(object.file_id) : "",
      newName: isSet(object.new_name) ? globalThis.String(object.new_name) : "",
      fileType: isSet(object.file_type) ? fileTypeFromJSON(object.file_type) : 0,
      contentType: isSet(object.content_type) ? globalThis.String(object.content_type) : "",
      content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : Buffer.alloc(0),
      status: isSet(object.status) ? fileStatusFromJSON(object.status) : 0,
      metadata: isObject(object.metadata) ? object.metadata : undefined,
    };
  },

  toJSON(message: UpdateFileRequest): unknown {
    const obj: any = {};
    if (message.context !== "") {
      obj.context = message.context;
    }
    if (message.fileId !== "") {
      obj.file_id = message.fileId;
    }
    if (message.newName !== "") {
      obj.new_name = message.newName;
    }
    if (message.fileType !== 0) {
      obj.file_type = fileTypeToJSON(message.fileType);
    }
    if (message.contentType !== "") {
      obj.content_type = message.contentType;
    }
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.status !== 0) {
      obj.status = fileStatusToJSON(message.status);
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateFileRequest>, I>>(base?: I): UpdateFileRequest {
    return UpdateFileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateFileRequest>, I>>(object: I): UpdateFileRequest {
    const message = createBaseUpdateFileRequest();
    message.context = object.context ?? "";
    message.fileId = object.fileId ?? "";
    message.newName = object.newName ?? "";
    message.fileType = object.fileType ?? 0;
    message.contentType = object.contentType ?? "";
    message.content = object.content ?? Buffer.alloc(0);
    message.status = object.status ?? 0;
    message.metadata = object.metadata ?? undefined;
    return message;
  },
};

function createBaseUpdateFileResponse(): UpdateFileResponse {
  return { result: undefined };
}

export const UpdateFileResponse: MessageFns<UpdateFileResponse> = {
  encode(message: UpdateFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== undefined) {
      FileResult.encode(message.result, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result = FileResult.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateFileResponse {
    return { result: isSet(object.result) ? FileResult.fromJSON(object.result) : undefined };
  },

  toJSON(message: UpdateFileResponse): unknown {
    const obj: any = {};
    if (message.result !== undefined) {
      obj.result = FileResult.toJSON(message.result);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateFileResponse>, I>>(base?: I): UpdateFileResponse {
    return UpdateFileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateFileResponse>, I>>(object: I): UpdateFileResponse {
    const message = createBaseUpdateFileResponse();
    message.result = (object.result !== undefined && object.result !== null)
      ? FileResult.fromPartial(object.result)
      : undefined;
    return message;
  },
};

function createBaseGetFilesRequest(): GetFilesRequest {
  return { context: "", filters: undefined, listSize: 0, offset: 0, order: "", includeContent: false };
}

export const GetFilesRequest: MessageFns<GetFilesRequest> = {
  encode(message: GetFilesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== "") {
      writer.uint32(10).string(message.context);
    }
    if (message.filters !== undefined) {
      FileFilter.encode(message.filters, writer.uint32(18).fork()).join();
    }
    if (message.listSize !== 0) {
      writer.uint32(24).int32(message.listSize);
    }
    if (message.offset !== 0) {
      writer.uint32(32).int32(message.offset);
    }
    if (message.order !== "") {
      writer.uint32(42).string(message.order);
    }
    if (message.includeContent !== false) {
      writer.uint32(48).bool(message.includeContent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFilesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFilesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.context = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filters = FileFilter.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.listSize = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.order = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.includeContent = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFilesRequest {
    return {
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      filters: isSet(object.filters) ? FileFilter.fromJSON(object.filters) : undefined,
      listSize: isSet(object.list_size) ? globalThis.Number(object.list_size) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
      order: isSet(object.order) ? globalThis.String(object.order) : "",
      includeContent: isSet(object.include_content) ? globalThis.Boolean(object.include_content) : false,
    };
  },

  toJSON(message: GetFilesRequest): unknown {
    const obj: any = {};
    if (message.context !== "") {
      obj.context = message.context;
    }
    if (message.filters !== undefined) {
      obj.filters = FileFilter.toJSON(message.filters);
    }
    if (message.listSize !== 0) {
      obj.list_size = Math.round(message.listSize);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    if (message.order !== "") {
      obj.order = message.order;
    }
    if (message.includeContent !== false) {
      obj.include_content = message.includeContent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFilesRequest>, I>>(base?: I): GetFilesRequest {
    return GetFilesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFilesRequest>, I>>(object: I): GetFilesRequest {
    const message = createBaseGetFilesRequest();
    message.context = object.context ?? "";
    message.filters = (object.filters !== undefined && object.filters !== null)
      ? FileFilter.fromPartial(object.filters)
      : undefined;
    message.listSize = object.listSize ?? 0;
    message.offset = object.offset ?? 0;
    message.order = object.order ?? "";
    message.includeContent = object.includeContent ?? false;
    return message;
  },
};

function createBaseGetFilesResponse(): GetFilesResponse {
  return { files: [], totalCount: 0 };
}

export const GetFilesResponse: MessageFns<GetFilesResponse> = {
  encode(message: GetFilesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.files) {
      File.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetFilesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetFilesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.files.push(File.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetFilesResponse {
    return {
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => File.fromJSON(e)) : [],
      totalCount: isSet(object.total_count) ? globalThis.Number(object.total_count) : 0,
    };
  },

  toJSON(message: GetFilesResponse): unknown {
    const obj: any = {};
    if (message.files?.length) {
      obj.files = message.files.map((e) => File.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.total_count = Math.round(message.totalCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetFilesResponse>, I>>(base?: I): GetFilesResponse {
    return GetFilesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetFilesResponse>, I>>(object: I): GetFilesResponse {
    const message = createBaseGetFilesResponse();
    message.files = object.files?.map((e) => File.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseDeleteFilesRequest(): DeleteFilesRequest {
  return { context: "", filters: undefined, force: false, permanent: false };
}

export const DeleteFilesRequest: MessageFns<DeleteFilesRequest> = {
  encode(message: DeleteFilesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.context !== "") {
      writer.uint32(10).string(message.context);
    }
    if (message.filters !== undefined) {
      FileFilter.encode(message.filters, writer.uint32(18).fork()).join();
    }
    if (message.force !== false) {
      writer.uint32(24).bool(message.force);
    }
    if (message.permanent !== false) {
      writer.uint32(32).bool(message.permanent);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFilesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFilesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.context = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.filters = FileFilter.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.force = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.permanent = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteFilesRequest {
    return {
      context: isSet(object.context) ? globalThis.String(object.context) : "",
      filters: isSet(object.filters) ? FileFilter.fromJSON(object.filters) : undefined,
      force: isSet(object.force) ? globalThis.Boolean(object.force) : false,
      permanent: isSet(object.permanent) ? globalThis.Boolean(object.permanent) : false,
    };
  },

  toJSON(message: DeleteFilesRequest): unknown {
    const obj: any = {};
    if (message.context !== "") {
      obj.context = message.context;
    }
    if (message.filters !== undefined) {
      obj.filters = FileFilter.toJSON(message.filters);
    }
    if (message.force !== false) {
      obj.force = message.force;
    }
    if (message.permanent !== false) {
      obj.permanent = message.permanent;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteFilesRequest>, I>>(base?: I): DeleteFilesRequest {
    return DeleteFilesRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteFilesRequest>, I>>(object: I): DeleteFilesRequest {
    const message = createBaseDeleteFilesRequest();
    message.context = object.context ?? "";
    message.filters = (object.filters !== undefined && object.filters !== null)
      ? FileFilter.fromPartial(object.filters)
      : undefined;
    message.force = object.force ?? false;
    message.permanent = object.permanent ?? false;
    return message;
  },
};

function createBaseDeleteFilesResponse(): DeleteFilesResponse {
  return { results: {}, totalDeleted: 0, totalFailed: 0 };
}

export const DeleteFilesResponse: MessageFns<DeleteFilesResponse> = {
  encode(message: DeleteFilesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.results).forEach(([key, value]) => {
      DeleteFilesResponse_ResultsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    if (message.totalDeleted !== 0) {
      writer.uint32(16).int32(message.totalDeleted);
    }
    if (message.totalFailed !== 0) {
      writer.uint32(24).int32(message.totalFailed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFilesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFilesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = DeleteFilesResponse_ResultsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.results[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalDeleted = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalFailed = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteFilesResponse {
    return {
      results: isObject(object.results)
        ? Object.entries(object.results).reduce<{ [key: string]: boolean }>((acc, [key, value]) => {
          acc[key] = Boolean(value);
          return acc;
        }, {})
        : {},
      totalDeleted: isSet(object.total_deleted) ? globalThis.Number(object.total_deleted) : 0,
      totalFailed: isSet(object.total_failed) ? globalThis.Number(object.total_failed) : 0,
    };
  },

  toJSON(message: DeleteFilesResponse): unknown {
    const obj: any = {};
    if (message.results) {
      const entries = Object.entries(message.results);
      if (entries.length > 0) {
        obj.results = {};
        entries.forEach(([k, v]) => {
          obj.results[k] = v;
        });
      }
    }
    if (message.totalDeleted !== 0) {
      obj.total_deleted = Math.round(message.totalDeleted);
    }
    if (message.totalFailed !== 0) {
      obj.total_failed = Math.round(message.totalFailed);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteFilesResponse>, I>>(base?: I): DeleteFilesResponse {
    return DeleteFilesResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteFilesResponse>, I>>(object: I): DeleteFilesResponse {
    const message = createBaseDeleteFilesResponse();
    message.results = Object.entries(object.results ?? {}).reduce<{ [key: string]: boolean }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Boolean(value);
      }
      return acc;
    }, {});
    message.totalDeleted = object.totalDeleted ?? 0;
    message.totalFailed = object.totalFailed ?? 0;
    return message;
  },
};

function createBaseDeleteFilesResponse_ResultsEntry(): DeleteFilesResponse_ResultsEntry {
  return { key: "", value: false };
}

export const DeleteFilesResponse_ResultsEntry: MessageFns<DeleteFilesResponse_ResultsEntry> = {
  encode(message: DeleteFilesResponse_ResultsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteFilesResponse_ResultsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteFilesResponse_ResultsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteFilesResponse_ResultsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
    };
  },

  toJSON(message: DeleteFilesResponse_ResultsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteFilesResponse_ResultsEntry>, I>>(
    base?: I,
  ): DeleteFilesResponse_ResultsEntry {
    return DeleteFilesResponse_ResultsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteFilesResponse_ResultsEntry>, I>>(
    object: I,
  ): DeleteFilesResponse_ResultsEntry {
    const message = createBaseDeleteFilesResponse_ResultsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? false;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
