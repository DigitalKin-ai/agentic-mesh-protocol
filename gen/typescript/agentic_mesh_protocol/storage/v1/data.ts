// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               unknown
// source: agentic_mesh_protocol/storage/v1/data.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Struct } from "../../../google/protobuf/struct.js";
import { Timestamp } from "../../../google/protobuf/timestamp.js";

export const protobufPackage = "agentic_mesh_protocol.storage.v1";

/** DataType: Enum to categorize the type of data being stored */
export enum DataType {
  /** UNSPECIFIED - UNSPECIFIED: Default unspecified data type */
  UNSPECIFIED = 0,
  /** OUTPUT - OUTPUT: Data generated by the system as output */
  OUTPUT = 1,
  /** VIEW - VIEW: Data intended for display/UI purposes */
  VIEW = 2,
  /** LOGS - LOGS: Log entries and debugging information */
  LOGS = 3,
  /** OTHER - OTHER: Other miscellaneous data types */
  OTHER = 4,
  UNRECOGNIZED = -1,
}

export function dataTypeFromJSON(object: any): DataType {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return DataType.UNSPECIFIED;
    case 1:
    case "OUTPUT":
      return DataType.OUTPUT;
    case 2:
    case "VIEW":
      return DataType.VIEW;
    case 3:
    case "LOGS":
      return DataType.LOGS;
    case 4:
    case "OTHER":
      return DataType.OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataType.UNRECOGNIZED;
  }
}

export function dataTypeToJSON(object: DataType): string {
  switch (object) {
    case DataType.UNSPECIFIED:
      return "UNSPECIFIED";
    case DataType.OUTPUT:
      return "OUTPUT";
    case DataType.VIEW:
      return "VIEW";
    case DataType.LOGS:
      return "LOGS";
    case DataType.OTHER:
      return "OTHER";
    case DataType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** StorageRecord: Message to represent stored data */
export interface StorageRecord {
  /** data: JSON Object to store */
  data?:
    | { [key: string]: any }
    | undefined;
  /** mission_id: Mission ID linked to the data */
  missionId: string;
  /** collection: Name of a group of records (unique by mission_id) */
  collection: string;
  /** record_id: Unique identifier for the record within collection */
  recordId: string;
  /** creation_date: Creation date of the data */
  creationDate?:
    | Date
    | undefined;
  /** update_date: Update date of the data */
  updateDate?:
    | Date
    | undefined;
  /** data_type: Type of the data */
  dataType: DataType;
}

/** StoreRecordRequest: Request to store record */
export interface StoreRecordRequest {
  /** data: Data to store or to retrieve */
  data?:
    | { [key: string]: any }
    | undefined;
  /** mission_id: Mission ID linked to the data */
  missionId: string;
  /** collection: Name of a group of records (unique by mission_id) */
  collection: string;
  /** record_id: Unique identifier for the record within collection */
  recordId: string;
  /** data_type: Type of the data */
  dataType: DataType;
}

/** StoreRecordResponse: Response to stored record */
export interface StoreRecordResponse {
  /** success: Success of the operation */
  success: boolean;
  /** stored_data: Stored data */
  storedData?: StorageRecord | undefined;
}

/** ReadRecordRequest: Request to read a record */
export interface ReadRecordRequest {
  /** mission_id: Mission ID linked to the data */
  missionId: string;
  /** collection: Name of a group of records (unique by mission_id) */
  collection: string;
  /** record_id: Unique identifier for the record within collection */
  recordId: string;
}

/** ReadRecordResponse: Response after read a record */
export interface ReadRecordResponse {
  /** success: Success of the operation */
  success: boolean;
  /** stored_data: Stored data */
  storedData?: StorageRecord | undefined;
}

/** UpdateRecordRequest: Request to modify record */
export interface UpdateRecordRequest {
  /** data: Data to store or to retrieve */
  data?:
    | { [key: string]: any }
    | undefined;
  /** mission_id: Mission ID linked to the data */
  missionId: string;
  /** collection: Name of a group of records (unique by mission_id) */
  collection: string;
  /** record_id: Unique identifier for the record within collection */
  recordId: string;
}

/** UpdateRecordResponse: Response to record modification */
export interface UpdateRecordResponse {
  /** success: Success of the operation */
  success: boolean;
  /** stored_data: Stored data */
  storedData?: StorageRecord | undefined;
}

/** RemoveRecordRequest: Request to remove a record */
export interface RemoveRecordRequest {
  /** mission_id: Mission ID linked to the data */
  missionId: string;
  /** collection: Name of a group of records (unique by mission_id) */
  collection: string;
  /** record_id: Unique identifier for the record within collection */
  recordId: string;
}

/** RemoveRecordResponse: Response to removed record */
export interface RemoveRecordResponse {
  /** success: Success of the operation */
  success: boolean;
}

/** ListRecordsRequest: Request to list all records in a given collection */
export interface ListRecordsRequest {
  /** mission_id: Mission ID linked to the data */
  missionId: string;
  /** collection: Name of a group of records (unique by mission_id) */
  collection: string;
}

/** ListRecordsResponse: Response to list all records in a given collection */
export interface ListRecordsResponse {
  /** records: List of records */
  records: StorageRecord[];
}

/** RemoveCollectionRequest: Request to remove a collection */
export interface RemoveCollectionRequest {
  /** mission_id: Mission ID linked to the data */
  missionId: string;
  /** collection: Name of a group of records (unique by mission_id) */
  collection: string;
}

/** RemoveCollectionResponse: Response to removed collection */
export interface RemoveCollectionResponse {
  /** success: Success of the operation */
  success: boolean;
}

function createBaseStorageRecord(): StorageRecord {
  return {
    data: undefined,
    missionId: "",
    collection: "",
    recordId: "",
    creationDate: undefined,
    updateDate: undefined,
    dataType: 0,
  };
}

export const StorageRecord: MessageFns<StorageRecord> = {
  encode(message: StorageRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(10).fork()).join();
    }
    if (message.missionId !== "") {
      writer.uint32(18).string(message.missionId);
    }
    if (message.collection !== "") {
      writer.uint32(26).string(message.collection);
    }
    if (message.recordId !== "") {
      writer.uint32(34).string(message.recordId);
    }
    if (message.creationDate !== undefined) {
      Timestamp.encode(toTimestamp(message.creationDate), writer.uint32(42).fork()).join();
    }
    if (message.updateDate !== undefined) {
      Timestamp.encode(toTimestamp(message.updateDate), writer.uint32(50).fork()).join();
    }
    if (message.dataType !== 0) {
      writer.uint32(56).int32(message.dataType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StorageRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStorageRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.missionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.recordId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.creationDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updateDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StorageRecord {
    return {
      data: isObject(object.data) ? object.data : undefined,
      missionId: isSet(object.mission_id) ? globalThis.String(object.mission_id) : "",
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      recordId: isSet(object.record_id) ? globalThis.String(object.record_id) : "",
      creationDate: isSet(object.creation_date) ? fromJsonTimestamp(object.creation_date) : undefined,
      updateDate: isSet(object.update_date) ? fromJsonTimestamp(object.update_date) : undefined,
      dataType: isSet(object.data_type) ? dataTypeFromJSON(object.data_type) : 0,
    };
  },

  toJSON(message: StorageRecord): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    if (message.missionId !== "") {
      obj.mission_id = message.missionId;
    }
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.recordId !== "") {
      obj.record_id = message.recordId;
    }
    if (message.creationDate !== undefined) {
      obj.creation_date = message.creationDate.toISOString();
    }
    if (message.updateDate !== undefined) {
      obj.update_date = message.updateDate.toISOString();
    }
    if (message.dataType !== 0) {
      obj.data_type = dataTypeToJSON(message.dataType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StorageRecord>, I>>(base?: I): StorageRecord {
    return StorageRecord.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StorageRecord>, I>>(object: I): StorageRecord {
    const message = createBaseStorageRecord();
    message.data = object.data ?? undefined;
    message.missionId = object.missionId ?? "";
    message.collection = object.collection ?? "";
    message.recordId = object.recordId ?? "";
    message.creationDate = object.creationDate ?? undefined;
    message.updateDate = object.updateDate ?? undefined;
    message.dataType = object.dataType ?? 0;
    return message;
  },
};

function createBaseStoreRecordRequest(): StoreRecordRequest {
  return { data: undefined, missionId: "", collection: "", recordId: "", dataType: 0 };
}

export const StoreRecordRequest: MessageFns<StoreRecordRequest> = {
  encode(message: StoreRecordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(10).fork()).join();
    }
    if (message.missionId !== "") {
      writer.uint32(18).string(message.missionId);
    }
    if (message.collection !== "") {
      writer.uint32(26).string(message.collection);
    }
    if (message.recordId !== "") {
      writer.uint32(34).string(message.recordId);
    }
    if (message.dataType !== 0) {
      writer.uint32(40).int32(message.dataType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreRecordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreRecordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.missionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.recordId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.dataType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StoreRecordRequest {
    return {
      data: isObject(object.data) ? object.data : undefined,
      missionId: isSet(object.mission_id) ? globalThis.String(object.mission_id) : "",
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      recordId: isSet(object.record_id) ? globalThis.String(object.record_id) : "",
      dataType: isSet(object.data_type) ? dataTypeFromJSON(object.data_type) : 0,
    };
  },

  toJSON(message: StoreRecordRequest): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    if (message.missionId !== "") {
      obj.mission_id = message.missionId;
    }
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.recordId !== "") {
      obj.record_id = message.recordId;
    }
    if (message.dataType !== 0) {
      obj.data_type = dataTypeToJSON(message.dataType);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StoreRecordRequest>, I>>(base?: I): StoreRecordRequest {
    return StoreRecordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StoreRecordRequest>, I>>(object: I): StoreRecordRequest {
    const message = createBaseStoreRecordRequest();
    message.data = object.data ?? undefined;
    message.missionId = object.missionId ?? "";
    message.collection = object.collection ?? "";
    message.recordId = object.recordId ?? "";
    message.dataType = object.dataType ?? 0;
    return message;
  },
};

function createBaseStoreRecordResponse(): StoreRecordResponse {
  return { success: false, storedData: undefined };
}

export const StoreRecordResponse: MessageFns<StoreRecordResponse> = {
  encode(message: StoreRecordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.storedData !== undefined) {
      StorageRecord.encode(message.storedData, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StoreRecordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStoreRecordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.storedData = StorageRecord.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StoreRecordResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      storedData: isSet(object.stored_data) ? StorageRecord.fromJSON(object.stored_data) : undefined,
    };
  },

  toJSON(message: StoreRecordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.storedData !== undefined) {
      obj.stored_data = StorageRecord.toJSON(message.storedData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StoreRecordResponse>, I>>(base?: I): StoreRecordResponse {
    return StoreRecordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StoreRecordResponse>, I>>(object: I): StoreRecordResponse {
    const message = createBaseStoreRecordResponse();
    message.success = object.success ?? false;
    message.storedData = (object.storedData !== undefined && object.storedData !== null)
      ? StorageRecord.fromPartial(object.storedData)
      : undefined;
    return message;
  },
};

function createBaseReadRecordRequest(): ReadRecordRequest {
  return { missionId: "", collection: "", recordId: "" };
}

export const ReadRecordRequest: MessageFns<ReadRecordRequest> = {
  encode(message: ReadRecordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.missionId !== "") {
      writer.uint32(10).string(message.missionId);
    }
    if (message.collection !== "") {
      writer.uint32(18).string(message.collection);
    }
    if (message.recordId !== "") {
      writer.uint32(26).string(message.recordId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadRecordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadRecordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.missionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.recordId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadRecordRequest {
    return {
      missionId: isSet(object.mission_id) ? globalThis.String(object.mission_id) : "",
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      recordId: isSet(object.record_id) ? globalThis.String(object.record_id) : "",
    };
  },

  toJSON(message: ReadRecordRequest): unknown {
    const obj: any = {};
    if (message.missionId !== "") {
      obj.mission_id = message.missionId;
    }
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.recordId !== "") {
      obj.record_id = message.recordId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadRecordRequest>, I>>(base?: I): ReadRecordRequest {
    return ReadRecordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadRecordRequest>, I>>(object: I): ReadRecordRequest {
    const message = createBaseReadRecordRequest();
    message.missionId = object.missionId ?? "";
    message.collection = object.collection ?? "";
    message.recordId = object.recordId ?? "";
    return message;
  },
};

function createBaseReadRecordResponse(): ReadRecordResponse {
  return { success: false, storedData: undefined };
}

export const ReadRecordResponse: MessageFns<ReadRecordResponse> = {
  encode(message: ReadRecordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.storedData !== undefined) {
      StorageRecord.encode(message.storedData, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadRecordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadRecordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.storedData = StorageRecord.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadRecordResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      storedData: isSet(object.stored_data) ? StorageRecord.fromJSON(object.stored_data) : undefined,
    };
  },

  toJSON(message: ReadRecordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.storedData !== undefined) {
      obj.stored_data = StorageRecord.toJSON(message.storedData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadRecordResponse>, I>>(base?: I): ReadRecordResponse {
    return ReadRecordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadRecordResponse>, I>>(object: I): ReadRecordResponse {
    const message = createBaseReadRecordResponse();
    message.success = object.success ?? false;
    message.storedData = (object.storedData !== undefined && object.storedData !== null)
      ? StorageRecord.fromPartial(object.storedData)
      : undefined;
    return message;
  },
};

function createBaseUpdateRecordRequest(): UpdateRecordRequest {
  return { data: undefined, missionId: "", collection: "", recordId: "" };
}

export const UpdateRecordRequest: MessageFns<UpdateRecordRequest> = {
  encode(message: UpdateRecordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== undefined) {
      Struct.encode(Struct.wrap(message.data), writer.uint32(10).fork()).join();
    }
    if (message.missionId !== "") {
      writer.uint32(18).string(message.missionId);
    }
    if (message.collection !== "") {
      writer.uint32(26).string(message.collection);
    }
    if (message.recordId !== "") {
      writer.uint32(34).string(message.recordId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRecordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRecordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = Struct.unwrap(Struct.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.missionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.recordId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRecordRequest {
    return {
      data: isObject(object.data) ? object.data : undefined,
      missionId: isSet(object.mission_id) ? globalThis.String(object.mission_id) : "",
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      recordId: isSet(object.record_id) ? globalThis.String(object.record_id) : "",
    };
  },

  toJSON(message: UpdateRecordRequest): unknown {
    const obj: any = {};
    if (message.data !== undefined) {
      obj.data = message.data;
    }
    if (message.missionId !== "") {
      obj.mission_id = message.missionId;
    }
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.recordId !== "") {
      obj.record_id = message.recordId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateRecordRequest>, I>>(base?: I): UpdateRecordRequest {
    return UpdateRecordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateRecordRequest>, I>>(object: I): UpdateRecordRequest {
    const message = createBaseUpdateRecordRequest();
    message.data = object.data ?? undefined;
    message.missionId = object.missionId ?? "";
    message.collection = object.collection ?? "";
    message.recordId = object.recordId ?? "";
    return message;
  },
};

function createBaseUpdateRecordResponse(): UpdateRecordResponse {
  return { success: false, storedData: undefined };
}

export const UpdateRecordResponse: MessageFns<UpdateRecordResponse> = {
  encode(message: UpdateRecordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.storedData !== undefined) {
      StorageRecord.encode(message.storedData, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRecordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRecordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.storedData = StorageRecord.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRecordResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      storedData: isSet(object.stored_data) ? StorageRecord.fromJSON(object.stored_data) : undefined,
    };
  },

  toJSON(message: UpdateRecordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.storedData !== undefined) {
      obj.stored_data = StorageRecord.toJSON(message.storedData);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateRecordResponse>, I>>(base?: I): UpdateRecordResponse {
    return UpdateRecordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateRecordResponse>, I>>(object: I): UpdateRecordResponse {
    const message = createBaseUpdateRecordResponse();
    message.success = object.success ?? false;
    message.storedData = (object.storedData !== undefined && object.storedData !== null)
      ? StorageRecord.fromPartial(object.storedData)
      : undefined;
    return message;
  },
};

function createBaseRemoveRecordRequest(): RemoveRecordRequest {
  return { missionId: "", collection: "", recordId: "" };
}

export const RemoveRecordRequest: MessageFns<RemoveRecordRequest> = {
  encode(message: RemoveRecordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.missionId !== "") {
      writer.uint32(10).string(message.missionId);
    }
    if (message.collection !== "") {
      writer.uint32(26).string(message.collection);
    }
    if (message.recordId !== "") {
      writer.uint32(34).string(message.recordId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveRecordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveRecordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.missionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.recordId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveRecordRequest {
    return {
      missionId: isSet(object.mission_id) ? globalThis.String(object.mission_id) : "",
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      recordId: isSet(object.record_id) ? globalThis.String(object.record_id) : "",
    };
  },

  toJSON(message: RemoveRecordRequest): unknown {
    const obj: any = {};
    if (message.missionId !== "") {
      obj.mission_id = message.missionId;
    }
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.recordId !== "") {
      obj.record_id = message.recordId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveRecordRequest>, I>>(base?: I): RemoveRecordRequest {
    return RemoveRecordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveRecordRequest>, I>>(object: I): RemoveRecordRequest {
    const message = createBaseRemoveRecordRequest();
    message.missionId = object.missionId ?? "";
    message.collection = object.collection ?? "";
    message.recordId = object.recordId ?? "";
    return message;
  },
};

function createBaseRemoveRecordResponse(): RemoveRecordResponse {
  return { success: false };
}

export const RemoveRecordResponse: MessageFns<RemoveRecordResponse> = {
  encode(message: RemoveRecordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveRecordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveRecordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveRecordResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: RemoveRecordResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveRecordResponse>, I>>(base?: I): RemoveRecordResponse {
    return RemoveRecordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveRecordResponse>, I>>(object: I): RemoveRecordResponse {
    const message = createBaseRemoveRecordResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseListRecordsRequest(): ListRecordsRequest {
  return { missionId: "", collection: "" };
}

export const ListRecordsRequest: MessageFns<ListRecordsRequest> = {
  encode(message: ListRecordsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.missionId !== "") {
      writer.uint32(10).string(message.missionId);
    }
    if (message.collection !== "") {
      writer.uint32(18).string(message.collection);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRecordsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRecordsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.missionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRecordsRequest {
    return {
      missionId: isSet(object.mission_id) ? globalThis.String(object.mission_id) : "",
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
    };
  },

  toJSON(message: ListRecordsRequest): unknown {
    const obj: any = {};
    if (message.missionId !== "") {
      obj.mission_id = message.missionId;
    }
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRecordsRequest>, I>>(base?: I): ListRecordsRequest {
    return ListRecordsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRecordsRequest>, I>>(object: I): ListRecordsRequest {
    const message = createBaseListRecordsRequest();
    message.missionId = object.missionId ?? "";
    message.collection = object.collection ?? "";
    return message;
  },
};

function createBaseListRecordsResponse(): ListRecordsResponse {
  return { records: [] };
}

export const ListRecordsResponse: MessageFns<ListRecordsResponse> = {
  encode(message: ListRecordsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.records) {
      StorageRecord.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRecordsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRecordsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.records.push(StorageRecord.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRecordsResponse {
    return {
      records: globalThis.Array.isArray(object?.records)
        ? object.records.map((e: any) => StorageRecord.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListRecordsResponse): unknown {
    const obj: any = {};
    if (message.records?.length) {
      obj.records = message.records.map((e) => StorageRecord.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ListRecordsResponse>, I>>(base?: I): ListRecordsResponse {
    return ListRecordsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ListRecordsResponse>, I>>(object: I): ListRecordsResponse {
    const message = createBaseListRecordsResponse();
    message.records = object.records?.map((e) => StorageRecord.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRemoveCollectionRequest(): RemoveCollectionRequest {
  return { missionId: "", collection: "" };
}

export const RemoveCollectionRequest: MessageFns<RemoveCollectionRequest> = {
  encode(message: RemoveCollectionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.missionId !== "") {
      writer.uint32(10).string(message.missionId);
    }
    if (message.collection !== "") {
      writer.uint32(18).string(message.collection);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveCollectionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveCollectionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.missionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.collection = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveCollectionRequest {
    return {
      missionId: isSet(object.mission_id) ? globalThis.String(object.mission_id) : "",
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
    };
  },

  toJSON(message: RemoveCollectionRequest): unknown {
    const obj: any = {};
    if (message.missionId !== "") {
      obj.mission_id = message.missionId;
    }
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveCollectionRequest>, I>>(base?: I): RemoveCollectionRequest {
    return RemoveCollectionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveCollectionRequest>, I>>(object: I): RemoveCollectionRequest {
    const message = createBaseRemoveCollectionRequest();
    message.missionId = object.missionId ?? "";
    message.collection = object.collection ?? "";
    return message;
  },
};

function createBaseRemoveCollectionResponse(): RemoveCollectionResponse {
  return { success: false };
}

export const RemoveCollectionResponse: MessageFns<RemoveCollectionResponse> = {
  encode(message: RemoveCollectionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveCollectionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveCollectionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoveCollectionResponse {
    return { success: isSet(object.success) ? globalThis.Boolean(object.success) : false };
  },

  toJSON(message: RemoveCollectionResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RemoveCollectionResponse>, I>>(base?: I): RemoveCollectionResponse {
    return RemoveCollectionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RemoveCollectionResponse>, I>>(object: I): RemoveCollectionResponse {
    const message = createBaseRemoveCollectionResponse();
    message.success = object.success ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000).toString();
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (globalThis.Number(t.seconds) || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
